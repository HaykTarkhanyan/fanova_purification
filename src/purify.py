
"""
Mass-moving purification for functional ANOVA (fANOVA) decomposition.

Implements the algorithm described in:
  Lengerich et al. (2020) "Purifying Interaction Effects with the Functional ANOVA:
  An Efficient Algorithm for Recovering Identifiable Additive Models".

Core idea:
- Start with an (over-parameterized) additive model with interactions represented as
  a collection of tensors T_u over discrete bins for each feature subset u.
- Iteratively "move mass" from higher-order tensors to lower-order tensors to enforce
  the fANOVA / integrate-to-zero constraints:
      E[f_u(X_u) | X_v] = 0 for all v âŠ‚ u
  which, in the discrete case, reduces to every 1D slice having zero weighted mean.

This implementation is general-purpose for discrete tensors of arbitrary order,
but the experiments in this repo focus on pairwise interactions.

Author: autogenerated for seminar reproducibility project.
"""
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Iterable, List, Mapping, MutableMapping, Optional, Sequence, Tuple

import numpy as np

Key = Tuple[int, ...]  # e.g., (), (0,), (1,), (0,1)


@dataclass(frozen=True)
class PurifyConfig:
    tol: float = 1e-10
    max_iter: int = 200
    verbose: bool = False


def _weighted_mean(values: np.ndarray, weights: np.ndarray) -> float:
    """Weighted mean with safe handling of zero-weight slices."""
    wsum = float(weights.sum())
    if wsum <= 0.0:
        return 0.0
    return float((values * weights).sum() / wsum)


def purify_tensor(
    tensors: MutableMapping[Key, np.ndarray | float],
    weights: Mapping[Key, np.ndarray],
    u: Key,
    config: PurifyConfig = PurifyConfig(),
) -> None:
    """
    Purify a single tensor T_u by repeatedly zeroing weighted slice-means.

    Parameters
    ----------
    tensors:
        Dict-like mapping from subset key u to tensor array. Must include () intercept as float.
    weights:
        Dict-like mapping from subset key u to weight tensor w_u of same shape as tensors[u],
        representing the marginal distribution over bins for variables in u.
        Each w_u should be non-negative; normalization is not required but recommended.
    u:
        Key of tensor to purify (must be in tensors and weights). u must be non-empty.
    config:
        Tolerance and iteration controls.

    Notes
    -----
    For each axis corresponding to a variable i in u, and for each fixed assignment of all
    other variables in u\{i}, we compute the weighted mean of that slice and "move" it into
    the lower-order tensor T_{u\{i}} to preserve the overall function.

    This matches the mass-moving idea from Alg. 1 in the paper, with the weighted mean
    computed as a conditional expectation (i.e., normalized by slice weight mass).
    """
    if len(u) == 0:
        raise ValueError("purify_tensor expects a non-empty key u.")

    if u not in tensors:
        raise KeyError(f"Tensor {u} not found in tensors.")
    if u not in weights:
        raise KeyError(f"Weights for {u} not found in weights.")

    Tu = tensors[u]
    if isinstance(Tu, (float, int)):
        raise TypeError(f"Tensor for u={u} must be an ndarray, got scalar.")

    Tu = np.asarray(Tu, dtype=float)
    Wu = np.asarray(weights[u], dtype=float)
    if Tu.shape != Wu.shape:
        raise ValueError(f"Shape mismatch for u={u}: Tu{Tu.shape} vs Wu{Wu.shape}")

    ndim = Tu.ndim
    if ndim != len(u):
        raise ValueError(f"Tensor dimension mismatch for u={u}: ndim={ndim} len(u)={len(u)}")

    # Ensure lower-order tensors exist
    for axis in range(ndim):
        u_lo = tuple([u[j] for j in range(ndim) if j != axis])
        if len(u_lo) == 0:
            if () not in tensors:
                tensors[()] = 0.0
        else:
            if u_lo not in tensors:
                # initialize to zeros
                shape_lo = tuple([Tu.shape[j] for j in range(ndim) if j != axis])
                tensors[u_lo] = np.zeros(shape_lo, dtype=float)

    # Iterative sweeps (Gauss-Seidel style)
    for it in range(config.max_iter):
        max_abs_m = 0.0

        for axis in range(ndim):
            u_lo = tuple([u[j] for j in range(ndim) if j != axis])

            # Iterate over all fixed indices for other axes
            shape_other = tuple([Tu.shape[j] for j in range(ndim) if j != axis])
            for idx_other in np.ndindex(*shape_other):
                # Build slicer for full tensor
                slicer = [slice(None)] * ndim
                other_pos = 0
                for j in range(ndim):
                    if j == axis:
                        continue
                    slicer[j] = idx_other[other_pos]
                    other_pos += 1
                slicer_t = tuple(slicer)

                vals = Tu[slicer_t]
                wts = Wu[slicer_t]
                m0 = _weighted_mean(vals, wts)
                if abs(m0) > config.tol:
                    # Move mass: subtract from higher-order slice, add to lower-order term
                    Tu[slicer_t] = vals - m0
                    if len(u_lo) == 0:
                        tensors[()] = float(tensors.get((), 0.0)) + m0
                    else:
                        tensors[u_lo][idx_other] = tensors[u_lo][idx_other] + m0
                    max_abs_m = max(max_abs_m, abs(m0))

        tensors[u] = Tu  # write back

        if config.verbose:
            print(f"purify_tensor u={u} iter={it} max|m|={max_abs_m:.3e}")

        if max_abs_m <= config.tol:
            break


def purify_all(
    tensors: MutableMapping[Key, np.ndarray | float],
    weights: Mapping[Key, np.ndarray],
    config: PurifyConfig = PurifyConfig(),
) -> MutableMapping[Key, np.ndarray | float]:
    """
    Purify all tensors in descending order of interaction order (|u|).

    Parameters
    ----------
    tensors:
        Mapping containing () intercept and any subset tensors to purify.
    weights:
        Must provide weights for all non-empty keys in tensors.
    config:
        PurifyConfig.

    Returns
    -------
    tensors (mutated in-place, also returned).
    """
    # Ensure intercept exists
    if () not in tensors:
        tensors[()] = 0.0

    keys = [k for k in tensors.keys() if len(k) > 0]
    keys_sorted = sorted(keys, key=lambda k: (len(k), k), reverse=True)
    for u in keys_sorted:
        purify_tensor(tensors, weights, u, config=config)

    return tensors


def check_purity(
    tensor: np.ndarray,
    weights: np.ndarray,
    tol: float = 1e-10,
) -> float:
    """
    Return the maximum absolute weighted slice-mean across all 1D slices.
    0 means perfectly purified (within numerical precision).
    """
    T = np.asarray(tensor, dtype=float)
    W = np.asarray(weights, dtype=float)
    if T.shape != W.shape:
        raise ValueError("Shape mismatch in check_purity")

    ndim = T.ndim
    max_abs_m = 0.0
    for axis in range(ndim):
        shape_other = tuple([T.shape[j] for j in range(ndim) if j != axis])
        for idx_other in np.ndindex(*shape_other):
            slicer = [slice(None)] * ndim
            other_pos = 0
            for j in range(ndim):
                if j == axis:
                    continue
                slicer[j] = idx_other[other_pos]
                other_pos += 1
            slicer_t = tuple(slicer)
            m0 = _weighted_mean(T[slicer_t], W[slicer_t])
            max_abs_m = max(max_abs_m, abs(m0))
    return max_abs_m
